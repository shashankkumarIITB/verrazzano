// Copyright (c) 2022, Oracle and/or its affiliates.
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

package metrics

import (
	"fmt"
	"strconv"

	promoperapi "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"github.com/verrazzano/verrazzano/application-operator/constants"
	vzconst "github.com/verrazzano/verrazzano/pkg/constants"
	"github.com/verrazzano/verrazzano/pkg/log/vzlog"
	corev1 "k8s.io/api/core/v1"
)

// PopulatePodMonitor populates the Pod Monitor to prepare for a create or update
// the Pod Monitor reflects the specifications defined in the ScrapeInfo object
func PopulatePodMonitor(info ScrapeInfo, podMonitor *promoperapi.PodMonitor, log vzlog.VerrazzanoLogger) error {
	// Create the Pod Monitor selector from the info label if it exists
	if podMonitor.ObjectMeta.Labels == nil {
		podMonitor.ObjectMeta.Labels = make(map[string]string)
	}
	podMonitor.Labels["release"] = "prometheus-operator"
	podMonitor.Spec.NamespaceSelector = promoperapi.NamespaceSelector{
		MatchNames: []string{podMonitor.GetNamespace()},
	}

	// Clear the existing endpoints to avoid duplications
	podMonitor.Spec.PodMetricsEndpoints = nil

	// Loop through ports in the info and create scrape targets for each
	for i := 0; i < info.Ports; i++ {
		endpoint, err := createPodMonitorEndpoint(info, i)
		if err != nil {
			return log.ErrorfNewErr("Failed to create an endpoint for the Pod Monitor: %v", err)
		}
		podMonitor.Spec.PodMetricsEndpoints = append(podMonitor.Spec.PodMetricsEndpoints, endpoint)
	}
	return nil
}

// createPodMonitorEndpoint creates an endpoint for a given port increment and info
// this function effectively creates a scrape config for the workload target through the Pod Monitor API
func createPodMonitorEndpoint(info ScrapeInfo, portIncrement int) (promoperapi.PodMetricsEndpoint, error) {
	var endpoint promoperapi.PodMetricsEndpoint

	// Add the secret username and password if basic auth is required for this endpoint
	// The secret has to exist in the workload and namespace
	if secret := info.BasicAuthSecret; secret != nil {
		endpoint.BasicAuth = &promoperapi.BasicAuth{
			Username: corev1.SecretKeySelector{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: secret.Name,
				},
				Key: "username",
			},
			Password: corev1.SecretKeySelector{
				LocalObjectReference: corev1.LocalObjectReference{
					Name: secret.Name,
				},
				Key: "password",
			},
		}
	}

	endpoint.Scheme = "http"
	endpoint.Path = "/metrics"
	if info.Path != nil {
		endpoint.Path = *info.Path
	}

	if info.IstioEnabled != nil && *info.IstioEnabled {
		// The Prometheus Pod contains Istio certificates from the installation process
		// These certs are generated by Istio and a secret is created from the TLS secret generator
		// Pod Monitors reference a local secret that gets copied from the generated secret in the verrazzano-monitoring namespace
		endpoint.Scheme = "https"
		endpoint.TLSConfig = &promoperapi.PodMetricsEndpointTLSConfig{
			SafeTLSConfig: promoperapi.SafeTLSConfig{
				CA: promoperapi.SecretOrConfigMap{
					Secret: &corev1.SecretKeySelector{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: vzconst.IstioTLSSecretName,
						},
						Key: vzconst.RootCertFileName,
					},
				},
				Cert: promoperapi.SecretOrConfigMap{
					Secret: &corev1.SecretKeySelector{
						LocalObjectReference: corev1.LocalObjectReference{
							Name: vzconst.IstioTLSSecretName,
						},
						Key: vzconst.CertChainFileName,
					},
				},
				KeySecret: &corev1.SecretKeySelector{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: vzconst.IstioTLSSecretName,
					},
					Key: vzconst.CertKeyFileName,
				},
			},
		}
		endpoint.TLSConfig.InsecureSkipVerify = true
	}

	// Change the expected labels based on the workload type
	enabledLabel := "__meta_kubernetes_pod_annotation_prometheus_io_scrape"
	portLabel := "__meta_kubernetes_pod_annotation_prometheus_io_port"
	pathLabel := "__meta_kubernetes_pod_annotation_prometheus_io_path"
	if info.VZPrometheusLabels != nil && *info.VZPrometheusLabels {
		var portString string
		if portIncrement > 0 {
			portString = strconv.Itoa(portIncrement)
		}
		enabledLabel = fmt.Sprintf("__meta_kubernetes_pod_annotation_verrazzano_io_metricsEnabled%s", portString)
		portLabel = fmt.Sprintf("__meta_kubernetes_pod_annotation_verrazzano_io_metricsPort%s", portString)
		pathLabel = fmt.Sprintf("__meta_kubernetes_pod_annotation_verrazzano_io_metricsPath%s", portString)
	}

	// Add default cluster name if not populated
	if info.ClusterName == "" {
		info.ClusterName = constants.DefaultClusterName
	}

	// Relabel the cluster name
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action:      "replace",
		Replacement: info.ClusterName,
		TargetLabel: prometheusClusterNameLabel,
	})

	// Relabel to match the expected labels
	regexString := "true"
	sourceLabels := []promoperapi.LabelName{promoperapi.LabelName(enabledLabel)}
	for key, val := range info.KeepLabels {
		sourceLabels = append(sourceLabels, promoperapi.LabelName(key))
		regexString = fmt.Sprintf("%s;%s", regexString, val)
	}
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action:       "keep",
		Regex:        regexString,
		SourceLabels: sourceLabels,
	})

	// Replace the metrics path if specified
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action: "replace",
		Regex:  "(.+)",
		SourceLabels: []promoperapi.LabelName{
			promoperapi.LabelName(pathLabel),
		},
		TargetLabel: "__metrics_path__",
	})

	// Relabel the address of the metrics endpoint
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action:      "replace",
		Regex:       `([^:]+)(?::\d+)?;(\d+)`,
		Replacement: "$1:$2",
		SourceLabels: []promoperapi.LabelName{
			"__address__",
			promoperapi.LabelName(portLabel),
		},
		TargetLabel: "__address__",
	})

	// Relabel the namespace label
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action:      "replace",
		Regex:       `(.*)`,
		Replacement: "$1",
		SourceLabels: []promoperapi.LabelName{
			"__meta_kubernetes_namespace",
		},
		TargetLabel: "namespace",
	})

	// Relabel the pod label
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action: "labelmap",
		Regex:  `__meta_kubernetes_pod_label_(.+)`,
	})

	// Relabel the pod name label
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action: "replace",
		SourceLabels: []promoperapi.LabelName{
			"__meta_kubernetes_pod_name",
		},
		TargetLabel: "pod_name",
	})

	// Drop the controller revision hash label
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action: "labeldrop",
		Regex:  `(controller_revision_hash)`,
	})

	// Relabel the webapp label
	endpoint.RelabelConfigs = append(endpoint.RelabelConfigs, &promoperapi.RelabelConfig{
		Action:      "replace",
		Regex:       `.*/(.*)$`,
		Replacement: "$1",
		SourceLabels: []promoperapi.LabelName{
			"name",
		},
		TargetLabel: "webapp",
	})

	return endpoint, nil
}
